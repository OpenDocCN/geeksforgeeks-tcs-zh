# 上下文无关语言的闭包属性

> 原文:[https://www . geesforgeks . org/closure-properties-of-context-free-languages/](https://www.geeksforgeeks.org/closure-properties-of-context-free-languages/)

[下推自动机](https://www.geeksforgeeks.org/introduction-of-pushdown-automata/)接受上下文无关语言。上下文无关语言可以由上下文无关语法生成，这些语法具有以下形式的产物(替换规则):

A -> ρ(其中 A ∈ N 和ρ ∈ (T ∪ N)*和 N 是非终结符，T 是终结符)

**上下文无关语言的属性**
**并集:**如果 L1 和 L2 是两种上下文无关语言，它们的并集 L1 ∪ L2 也将是上下文无关的。例如，
L1 = { a<sup>n</sup>b<sup>n</sup>c<sup>m</sup>| m>= 0 和 n>= 0 } L2 = { a<sup>n</sup>b<sup>m</sup>c<sup>m</sup>| n>= 0 和 m > = 0 }
L3 = L1∪L2 = { a<sup>n</sup>b<sup>n</sup>c<sup>m</sup>∪a<sup>n</sup>b<sup>m</sup>c<sup>m</sup>| n>= 0，m > = 0 }也是上下文无关的。
L1 说 a 的个数应该等于 b 的个数，L2 说 b 的个数应该等于 c 的个数。他们的工会认为两个条件中的任何一个都是正确的。所以它也是上下文无关的语言。

**注:**所以 CFL 在合纵之下是封闭的。

**串联:**如果 L1 和 L2 是两种上下文无关的语言，那么它们的串联就是 L1。L2 也将不受环境影响。例如，
L1 = { a<sup>n</sup>b<sup>n</sup>| n>= 0 } L2 = { c<sup>m</sup>d<sup>m</sup>| m>= 0 }
L3 = L1。L2 = { a<sup>n</sup>b<sup>n</sup>c<sup>m</sup>d<sup>m</sup>| m>= 0，n > = 0}也是上下文无关的。
L1 说 a 的数量应该等于 b 的数量，L2 说 c 的数量应该等于 d 的数量。它们的连接表示首先 a 的数量应该等于 b 的数量，然后 c 的数量应该等于 d 的数量。因此，我们可以创建一个 PDA，它将首先推动 a，流行为 b，推动 c，然后流行为 d。所以它可以被下推自动机接受，因此是上下文无关的。

**注:**所以 CFL 在拼接下闭合。

**克莱尼封端:**如果 L1 是上下文无关的，那么其克莱尼封端 L1*也将是上下文无关的。例如，
L1 = { a<sup>n</sup>b<sup>n</sup>| n>= 0 }
L1 * = { a<sup>n</sup>b<sup>n</sup>| n>= 0 } *也是上下文无关的。

**注:**所以 CFL 在克莱恩关闭下关闭。

**交集与互补:**如果 L1 和 L2 是两种上下文无关的语言，那么它们的交集 L1∪L2 就不需要上下文无关。例如，
L1 = { a<sup>n</sup>b<sup>n</sup>c<sup>m</sup>| n>= 0 和 m>= 0 } L2 =(a<sup>m</sup>b<sup>n</sup>c<sup>n</sup>| n>= 0 和 m>= 0 }
L3 = L1∪L2 = { a<sup>n【T18
L1 说 a 的个数应该等于 b 的个数，L2 说 b 的个数应该等于 c 的个数。他们的交集表示两个条件都需要为真，但下推自动机只能比较两个。所以它不能被下推自动机接受，因此不是上下文无关的。
同样，L1 的上下文无关语言∞*–L1 的互补不需要上下文无关。</sup>

**注:**所以 CFL 在交集和互补下不封闭。

**确定性上下文无关语言**
确定性 CFL 是 CFL 的子集，可以被确定性 PDA 识别。确定性 PDA 从给定状态和输入符号只有一次移动，即它没有选择。一种语言要成为 DCFL 语，应该清楚什么时候该推或流行。

例如，L1 = { a<sup>n</sup>b<sup>n</sup>c<sup>m</sup>| m>= 0 和 n > = 0}是 DCFL，因为对于 a，我们可以推进堆栈，对于 b，我们可以弹出。它可以被确定性 PDA 所识别。另一方面，L3 = { a<sup>n</sup>b<sup>n</sup>c<sup>m</sup>∪a<sup>n</sup>b<sup>m</sup>c<sup>m</sup>| n>= 0，m > = 0 }不能被 DPDA 识别，因为 a 和 b 的数量可以相等，或者 b 和 c 的数量可以相等。所以，只能由 NPDA 来执行。因此，它是 CFL，而不是 DCFL。
**注:** DCFL 只在互补和逆同态下闭合。

**提问:**考虑下面给出的语言 L1、L2、L3。
L1 = { a<sup>m</sup>b<sup>n</sup>m，n>= 0 }
L2 = { a<sup>n</sup>b<sup>n</sup>| n>= 0 }
L3 = { a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>n>= 0 }
哪一个
A .下推自动机(PDA)可以识别 L1 和 L2
B. L1 是正则语言
C .三种语言都是上下文无关的
D .图灵机可以识别三种语言

**解决方案:**选项(A)表示可以用 PDA 来识别 L1 和 L2。L1 包含所有的字符串，任何数字的 a 后面跟任何数字的 b。所以，它可以被 PDA 接受。L2 包含 n 个 a 后跟 n 个 b 的字符串。PDA 也可以接受。所以，选项(A)是正确的。
选项(B)表示 L1 是正规的。这是真的，因为 L1 的正则表达式是 a*b*。
选项(C)表示 L1、L2 和 L3 是上下文无关的。L3 语言包含所有带有 n 个 a，n 个 b，n 个 c 的字符串。但是 PDA 不能接受。所以选项(C)是不正确的。
选项(D)是正确的，因为图灵机可以用来识别所有三种语言。

**问题:**字母表{ 0，1，2}上的语言 L = { 0 <sup>i</sup> 12 <sup>i</sup> | i ≥ 0 }是:
A .不是递归的
B .是递归的确定性的 CFL
C .是正则的
D .是 CFL bot 不是确定性的 CFL。

**解决方案:**以上语言是确定性的 CFL 至于 0，我们可以在栈上推 0，对于 2，我们可以弹出相应的 0，由于没有取哪个动作的歧义，所以是确定性的。所以，正确的选项是(B)。因为 CFL 是递归的子集，所以它也是递归的。

**问题:**考虑以下语言:
L1 = { 0<sup>n</sup>1<sup>n</sup>| n≥0 }
L2 = { wcwr | wɛ{ a，b}* }
L3 = { wwr | w ɛ {a，b}* }
这些语言中哪些是确定性上下文无关语言？
A .没有语言
B .只有 L1
C .只有 L1 和 L2
D .所有三种语言

**解决方案:**语言 L1 包含所有 n ^ 0 后跟 n ^ 1 的字符串，可以构造确定性的 PDA 来接受 L1。对于 0，我们可以将它推到堆栈上，对于 1，我们可以从堆栈弹出。因此，它就是 DCFL。
L2 包含 wcwr 形式的所有字符串，其中 w 是 a 和 b 的字符串，wr 是 w 的反义词，例如 aabbcbbaa。为了接受这种语言，我们可以构造 PDA，它将把堆栈上的所有符号推到 c 之前。在 c 之后，如果输入字符串上的符号与堆栈上的符号匹配，它就会弹出。所以，L2 也可以被决定性的 PDA 接受，因此它也是 DCFL。
L3 包含 wwr 形式的所有字符串，其中 w 是 a 和 b 的字符串，wr 是 w 的反义词，但是我们不知道 w 从哪里结束，wr 从哪里开始。例如:aabbaa 是对应 L3 的字符串。首先，我们将把它放在堆栈上。接下来，a 可以是 w 的一部分，也可以是 wr 的一部分，其中 w=a。因此，从一个状态到一个输入符号，可以有多次移动。所以，只有非确定性的 PDA 可以用来接受这种类型的语言。因此，这是 NCFL，而不是 DCFL。
所以，正确的选项是(C)。只是，L1 和 L2 是 DCFL。

**问题:**以下哪个语法生成语言 l = { a<sup>I</sup>b<sup>j</sup>| I≠j }
s->AC | CB，C - > aCb | a | b，A - > aA | ɛ，b->bb |ɛ
s->as | sb | a | b
s-> C - > aCb | ɛ，A - > aA | ɛ，B - > Bb | ɛ
S - > AC | CB，C - > aCb | ɛ，A - > aA | a，B - > Bb | b

**解决方法:**解决这类问题的最好方法是排除不满足条件的选项。语言 L 的条件是 a 的数和 b 的数应该不相等。
在选项(B)中，S = > aS = > ab。它可以生成 a 和 b 相等的字符串。所以，这个选项是不正确的。
在选项(c)中，S = > AC = > C = > ɛ.在ɛ，a 和 b 是相等的(0)，所以这不是正确的选择。
在选项(A)中，S 将被 AC 或 CB 替代。c 要么生成的 a 数比 b 数多 1，要么生成的 b 数比 a 数多 1。但是多一个 a 或者多一个 b 可以分别被 B - > bB | ɛ或者 A - > aA | ɛ补偿。所以它可能会给出 a 和 b 数目相等的字符串。所以，这不是一个正确的选择。
在选项(D)中，S 将被 AC 或 CB 替代。c 总是会产生相等数量的 a 和 b。如果我们用交流代替 S，A 加上至少一个额外的 A。如果我们用交流代替 S，B 会加上至少一个额外的 B。所以这个语法永远不会产生相等数量的 A 和 B。所以，选项(D)是正确的。

本文由 Sonal Tuteja 供稿。

发现有不正确的地方请写评论，或者想分享更多以上讨论话题的信息
# 构造 L = {0(n+m)1m2n | m，n ≥ 0}的下推自动机

> 原文:[https://www . geesforgeks . org/construct-push down-automat-for-l-0nm1 m2n-m-n-0/](https://www.geeksforgeeks.org/construct-pushdown-automata-for-l-0nm1m2n-m-n-0/)

先决条件–[下推自动机](https://www.geeksforgeeks.org/theory-of-computation-pushdown-automata/)

**问题:**构造 L = { 0<sup>(n+m)</sup>1<sup>m</sup>2<sup>n</sup>| m，n ≥ 0}的下推自动机

**类似 PDA 的-**

*   这个 PDA 好像和 S2 的 PDA 差不多= { 0<sup>m</sup>1<sup>(n+m)</sup>2<sup>n</sup>但是产量不一样。S2 将生产 1 的数量等于 0 和 2 的数量之和的产品，而 S1 不生产。
*   这个 PDA 似乎类似于 PDA 的语言 L2 = { a<sup>m</sup>b<sup>(n+m)</sup>c<sup>n</sup>| m，n > 1}但是 L2 不包含任何长度为 0，1，2，3 的产物。而这个 PDA 将接受空字符串，长度为 1、2、3 的字符串除了被语言 L2 的 PDA 接受的字符串之外。

**示例-**

```
Input: NULL String
Output: Accepted

Input: 0000011122
Output: Accepted

Input: 00000112222
Output: Not Accepted  
```

**在这个 PDA–**
中使用的方法在处理给定的输入字符串时可能有四种情况。

**情况 1- m=0:**
在这种情况下，输入字符串的形式为{0 <sup>n</sup> 2 <sup>n</sup> }。在这种情况下，继续推动堆栈中的 0，直到我们遇到 2。收到 2 时，检查堆栈顶部是否为 0，然后将其从堆栈中弹出。继续弹出 0，直到处理完字符串的所有 2。如果我们到达输入字符串的末尾，堆栈变空，然后到达最终状态，即接受输入字符串，否则移动到死状态。

**情况 2- n=0:**
在这种情况下，输入字符串的形式为{0 <sup>m</sup> 1 <sup>m</sup> }。在这种情况下，继续推动堆栈中的 0，直到我们遇到 1。收到 1 时，检查堆栈顶部是否为 0，然后将其从堆栈中弹出。继续弹出 0，直到处理完字符串的所有 1。如果我们到达输入字符串的末尾，堆栈变空，然后到达最终状态，即接受输入字符串，否则移动到死状态。

**情况 3- m，n > 0:**
在这种情况下，输入字符串的形式为{ 0<sup>(n+m)</sup>1<sup>m</sup>2<sup>n</sup>}。在这种情况下，继续推动堆栈中的 0，直到我们遇到 1。收到 1 时，检查堆栈顶部是否为 0，然后将其从堆栈中弹出。继续弹出 0，直到处理完输入字符串的所有 1。之后，在接收 2 时，检查堆栈顶部是否为 0，然后将其从堆栈中弹出。继续弹出 0，直到处理完输入字符串的所有 2。如果我们到达输入字符串的末尾，堆栈变空，则到达最终状态，即接受输入字符串，否则移动到死状态。

**情况 4- m=0，n=0:**
在这种情况下，输入字符串将为空。因此直接跳到最终状态。

**状态转移图:**

![](img/30f24df1f1a6c4b0dc77352b76e0db05.png)